#include <iostream>
using namespace std;

struct lnode{
    int data;
    struct lnode *next;
};

typedef struct lnode *LPTR;

void addbegin(int x,LPTR &L){
    LPTR T;
    T = new struct lnode;
    T->data = x;
    T->next = L;
    L = T;
}

void addafter(int x,int y,LPTR &L){
    LPTR T;
    T = new struct lnode;
    LPTR T1;
    T1 = new struct lnode;
    T1 = L;
    while(T1->data != y){T1 = T1->next ;}
    T->data = x;
    T->next = T1->next;
    T1->next = T;
}

void addbefore(int x,int y,LPTR &L){
    LPTR T;
    T = new struct lnode;
    LPTR T1;
    T1 = new struct lnode;
    T1 = L;
    if(T1->data == y){addbegin(x,L);return;}
    while(T1->next->data != y){T1 = T1->next ;}
    T->data = x;
    T->next = T1->next;
    T1->next = T;
}

void add(int x,LPTR &L){
    if(L == NULL){addbegin(x,L);return;}
    LPTR T;
    T = new struct lnode;
    LPTR T1;
    T1 = new struct lnode;
    T1 = L;
    while(T1->next != NULL){T1 = T1->next;}
    T->data = x;
    T1->next = T;
    T->next = NULL;
}

void printl(LPTR &L){
    LPTR T;
    T = new struct lnode;
    T = L;
    while(T!=NULL){
        cout << T->data << " ";
        T = T->next;
    }
}

void deletebegin(LPTR &L){
    L = L->next;
}

void del(int y,LPTR &L){
    LPTR T;
    T = new struct lnode;
    LPTR T1;
    T1 = new struct lnode;
    T1 = L;
    if(T1->data == y){deletebegin(L);return;}
    while(T1->next->data != y){T1 = T1->next ;}
    T = T1->next;
    T1->next = T->next;
    delete(T);
}

int cnt(LPTR &L){
    static int i = 0;
    if(L==NULL){return i;}
    else{i++;return cnt(L->next) ;}
}

int searc(int y,LPTR &L){
    LPTR T;
    T = new struct lnode;
    T = L;
    if(L==NULL){return 0;}
    else if(T->data == y){return 1;}
    else{return searc(y,L->next);}
}

int mid(LPTR &L){
    LPTR s = new struct lnode;
    s = L;
    LPTR f = L;
    while(f->next != NULL && f->next->next != NULL){
        s = s->next;f = f->next->next;
    }
    return s->data;
}

struct stack{
    int element[50];
    int size;
    int top;
};

void push(int x,struct stack &S){
    if(S.top == S.size){cout << "The stack is full." << endl;}
    else{
        S.top++;
        S.element[S.top] = x;
    }
}

int pop(struct stack &S){
    if(S.top == -1){cout << "The stack is empty" << endl;return -1;}
    else{
        return S.element[S.top--];
    }
}

int peek(struct stack &S){
    if(S.top == -1){cout << "The stack is empty" << endl;return -1;}
    else{
        return S.element[S.top];
    }
}

int main()
{
    LPTR L = NULL;

    cout << "Enter LL and press -1 to exit." << endl;
    while(1){
        int x;cin >> x;
        if(x == -1){break;}
        add(x,L);
    }

    stack S;
    S.top = -1;S.size = 30;

    int m = mid(L);
    if(cnt(L)%2 == 0){
        LPTR T = new lnode;
        T = L;
        while(T->data != m){push(T->data,S);T = T->next;}
        push(T->data,S);T = T->next;
        while(T->data == peek(S) && T->next!=NULL && S.top!=-1){pop(S);T = T->next;}
        if(T->next==NULL && T->data==peek(S)){cout << "YES" << endl;}
        else{cout << "NO" << endl;}
    }
    else{
        LPTR T = new lnode;
        T = L;
        while(T->data != m){push(T->data,S);T = T->next;}
        T = T->next;
        while(T->data == peek(S) && T->next!=NULL && S.top!=-1){pop(S);T = T->next;}
        if(T->next==NULL && T->data==peek(S)){cout << "YES" << endl;}
        else{cout << "NO" << endl;}
    }

    return 0;
}
